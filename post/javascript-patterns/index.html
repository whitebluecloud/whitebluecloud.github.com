<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Javascript Patterns |  hun</title>
    <meta name="description" content="hun">
    <meta name="author" content="hun">
    <meta name="keywords" content="nodejs" />
    <meta name="generator" content="haroopress v0.9.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="/rss.xml" rel="alternate" title="hun" type="application/rss+xml">

    <!-- Le styles -->
    <link rel="canonical" href="http://whitebluecloud.github.com">

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/bootstrap-responsive.css" rel="stylesheet">
    <link href="/css/font-awesome.css" rel="stylesheet">
    <link href="/css/markdown.css" rel="stylesheet">
    <link href="/css/haroopress.css" rel="stylesheet">
    <link href="/css/theme.css" rel="stylesheet">
    <link href="/css/code/default.css" rel="stylesheet">
    
    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="72x72" href="/favicon-64.png">

    <!-- Le javascript -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/jquery.jsonp.js"></script>
    <script src="/js/mustache.js"></script>
    <script src="/js/apps/github.js"></script>
    <script src="/js/apps/twitter.js"></script>
</head>
<body data-spy="scroll" data-target=".subnav" data-offset="50">

        <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>

          <a class="pull-right" href="/rss.xml"><img src="/img/buttons/rss.png" /></a>
          

          <div class="nav-collapse">
            <ul class="nav">
              <li>
                <a href="/">Home</a>
              </li>
              <li>
                <a href="/archives">Archives</a>
              </li>
              <li>
                <a href="/slides">Slides</a>
              </li>
                
            </ul>
          </div>
        </div>
      </div>
    </div>

    
<link href="/css/code/default.css" rel="stylesheet">
<div class="container page-archive">
    <div class="row">
        <div class="span3">
            <div id="author" class="well">
                <div>
                    <h3>About Author</h3>
                    <ul class="thumbnails">
                        <li>
                            <a class="thumbnail">
                                <img src="http://www.gravatar.com/avatar/969a14eb11d6ca9e6a742dc036529bd9?r=pg&amp;s=128.jpg&amp;d=identicon" />
                            </a>
                        </li>
                    </ul>
                    <p>
                        <strong>hun</strong><br/>
                        blog: <a href="undefined" target="_blank"></a><br/>
                        twitter: <a href="http://twitter.com/undefined" target="_blank">@</a><br/>
                        github: <a href="https://github.com/undefined" target="_blank">http://whitebluecloud.github.com</a>
                    </p>
                    <p>
                        <a href="https://twitter.com/" class="twitter-follow-button" data-show-count="true">Follow @</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                    </p>
                    <p>
                        
                    </p>
                </div>
                <div>
                    <h3>About this Article</h3>
                    <p>
                        <h5>Date Released:</h5>
                        <span>Tuesday, January 22 2013 1:12 AM</span>
                    </p>
                </div>
            </div>
                        <div class="well">
                <ul class="nav nav-list">
                    <li class="nav-header">Categories</li>
                    <li class=""><a href="/category"><i class="icon-home"></i> Home</a></li>
                    
                    <li><a href="/category/javscript"><i class="icon-book"></i> javscript</a></li>
                    
                    <li><a href="/category/aws"><i class="icon-book"></i> aws</a></li>
                    
                    <li><a href="/category/nodejs"><i class="icon-book"></i> nodejs</a></li>
                    
                </ul>
            </div>

            
<div class="well">
    <ul class="nav nav-list">
        <li class="nav-header">Recent Articles</li>
    
        <li>
            <a href="/post/javascript-patterns" target="_blank">Javascript Patterns
            <span class="label">hun</span></a>
        </li>
    
        <li>
            <a href="/post/start-node-dot-j-s" target="_blank">Start Node.JS
            <span class="label">hun</span></a>
        </li>
    
        <li>
            <a href="/post/Amazon-Web-Service" target="_blank">Amazon Web Service
            <span class="label">hun</span></a>
        </li>
    
    </ul>
</div>

        </div>
        <div class="span9">
            <div class="row">
                <div class="span9">
                    <div class="well bg">
                        
                        <div class="page-header">
                            <h1>Javascript Patterns</h1>
                        </div>

                        
                                            

                                            

                        <div class="markdown-wrapper">
                            <p>자바스크립트 코딩기법과 핵심패턴에 대해 프린트하여 보기 좋게 정리하기 위해 포스팅</p>
<h1 id="toc_0">기초</h1>

<h2 id="toc_1">유지보수 가능한 코드 작성</h2>
<p>유지보수가 가능한 코드란 다음과 같은 특징을 가짐
읽기 쉽다.
일관적이다.
예측 가능하다.
한 사람이 작성한 것처럼 보인다.
문서화되어 있다.</p>
<h2 id="toc_2">전역변수를 최소화 하라!</h2>
<p>전역변수는 자바스크립트 애플리케이션이나 웹페이지 모든 코드 사이에서 공유된다는 문제점이 있다.
그러므로 전역변수는 최소한으로 사용한다.</p><pre><code class="javscript">myglobal = <span class="string">"hello"</span>; <span class="comment">//안티패턴</span>
console<span class="variable">.log</span>(myglobal); <span class="comment">//hello</span>
console<span class="variable">.log</span>(<span class="keyword">this</span><span class="variable">.myglobal</span>); <span class="comment">//hello</span>
console<span class="variable">.log</span>(window<span class="variable">.myglobal</span>); <span class="comment">//hello</span>
console<span class="variable">.log</span>(window[<span class="string">"myglobal"</span>]); <span class="comment">//hello</span>
</code></pre>
<h2 id="toc_3">암묵적 전역(implied globals)</h2>
<p>암묵적 전역은 절대적으로 피하는 것이 좋다. 아래 예도 그렇지만 다른 이유로 이식성(portability) 때문. 암묵적 전역 변수가 새로운 실행환경에서 호스트 객체를 의도치 않게 덮어쓸 수 있기 때문. </p><pre><code class="javscript"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(x, y)</span> {</span>
    result = x + y; <span class="comment">//안티패턴 - 전역 네임스페이스에 result 변수가 남게된다.</span>
    <span class="keyword">return</span> result;
}

<span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(x, y)</span> {</span>
    <span class="keyword">var</span> result = x + y; <span class="comment">//추천패턴 - 언제나 var을 사용해 변수를 선언해야 한다. 이때 result는 지역변수가 된다.</span>
    <span class="keyword">return</span> result;
}

<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> a = b = <span class="number">0</span>; <span class="comment">//안티패턴 - 이것은 var a = (b = 0); 과 같다. 즉 b가 암묵적 전역이 된다.</span>
}

<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> a, b;
    a = b = <span class="number">0</span>; <span class="comment">//추천패턴 - 이 경우 모두 지역변수가 된다.</span>
}
</code></pre>
<h2 id="toc_4">단일 var 패턴을 사용하라</h2>
<p>아래처럼 사용하는 패턴이 좋다. 장점은 변수 찾기 용이(명시적)이며, 로직상 오류를 방지(예를 들어 호이스팅)한다. 또한 의도적이지 않은 전역 변수 사용을 최소화할 수 있다. 뿐만아니라 코드링이 줄어든다. </p><pre><code class="javscript"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> <span class="comment">{
    var a = 1,
    b = 2,
    sum = a + b,
    myobject = {}</span>,
    <span class="title">el</span> = <span class="title">document</span>.<span class="title">getElementById</span><span class="params">("result")</span>,
    <span class="title">style</span> = <span class="title">el</span>.<span class="title">style</span>
    <span class="title">i</span>,
    <span class="title">j</span>;</span>
}
</code></pre>
<h2 id="toc_5">호이스팅(hoisting)</h2>
<p>호이스팅(끌어올리기)은 함수내에 어디서든 var 선언을 사용하더라도 함수 상단에 선언한 것과 동일한 동작을 하는 방식을 말함. 중요한 것은 선언만 호이스팅되는 것이지... 정의는 호이스팅 되지 않는다. </p>
<h2 id="toc_6">for 루프</h2>
<p>다음처럼은 절대 쓰지 않는다. </p><pre><code class="javscript"><span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="transposed_variable">myArray.</span><span class="built_in">length</span>; <span class="built_in">i</span>++) <span class="cell">{
    //myarray[i]를 다루는 코드
}</span>
</code></pre><p>다음 처럼 쓴다.</p><pre><code class="javscript"><span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span>, max = <span class="transposed_variable">myarray.</span><span class="built_in">length</span>; <span class="built_in">i</span> &lt; max; <span class="built_in">i</span>++) <span class="cell">{
    //myarray[i]를 다루는 코드
}</span>
</code></pre><p>for내에 var 선언은 단일 var 패턴을 해도 된다. 
i++대신 i = 1을 사용하는 것이 좋다. +, --는 과도한 기교를 조장한다는 이유이다.</p><p>미세 최적화를 위해 두가지 패턴을 활용한다.
변수를 하나 덜 쓴다.
카운트를 거꾸로 0으로 내려간다. 0과 비교하는 것이 0이 아닌 값으로 비교하는 것보다 빠르기 때문.</p>
<h2 id="toc_7">for-in 루프</h2>
<p>for-in으로 루프를 도는 것을 열거(enumeration)라고 한다. 이 루프는 반드시 배열이 아닌 객체를 순회할 때만 사용한다. </p><p>프로토타입 프로퍼티만을 걸러내기 위해 hasOwnProperty() 메서드를 사용한다. </p><pre><code class="javscript"><span class="function"><span class="title">for</span><span class="params">(var i in man)</span> {
    <span class="title">if</span><span class="params">(man.<span class="function_name">hasOwnProperty</span>(i))</span> {
        <span class="title">console</span>.<span class="title">log</span><span class="params">(i, <span class="string">":"</span>, man[i])</span>;
    }
}
</code></pre><p>다음처럼 해도 된다. 이 방법은 man객체가 hasOwnProperty를 재정의하여 덮어써도 활용할 수 있다. </p><pre><code class="javscript">var i,
    has<span class="variable">Own</span> = <span class="variable">Object</span>.prototype.has<span class="variable">OwnProperty</span>;
<span class="function"><span class="title">for</span><span class="params">(i in man)</span> {
    <span class="title">if</span><span class="params">(has<span class="variable">Own</span>.<span class="function_name">call</span>(m, i))</span> {
        <span class="title">console</span>.<span class="title">log</span><span class="params">(i, <span class="string">":"</span>, man[i])</span>;
    }
}
</code></pre><p>내장 생성자 프로토타입은 되도록 확장하지 말자.
생성자 함수의 prototype 프로퍼티를 확장하는 것은 기능을 추가하는 좋은 방법이나 너무 강력함. 
그러므로 Object(), Array(), Function()과 같은 내장 생성자의 프로토타입을 확장하는 것은 매력적이나 코드의 지속성을 심각하게 저해할 수 있다.
하지만 무조건 나쁘지만은 않으므로 꼭 필요한 경우 정의한다.</p><pre><code class="javscript"><span class="keyword">if</span> (typeof Object.prototype.myMethod !== <span class="string">"function"</span>) {
    Object.prototype.myMethod = <span class="keyword">function</span> () {  
        // 구현<span class="keyword">...</span>
    };
}
</code></pre>
<h2 id="toc_8">switch 패턴</h2>
<p>case문을 switch문에 맞추어 정렬
case문 안에서 코드를 들여쓰기 한다.
case문은 명확히 break;로 종료
break문을 생략하여 통과시키지 않는다. 필요한 경우 기록을 남긴다.
반드시 default:을 쓴다.</p><pre><code class="javscript">switch( inspect_me) {
    case <span class="number">0</span>:
        result = <span class="string">"zero"</span><span class="comment">;</span>
        <span class="keyword">break</span><span class="comment">;</span>
    case <span class="number">1</span>:
        result = <span class="string">"one"</span><span class="comment">;</span>
        <span class="keyword">break</span><span class="comment">;</span>
    default:
        result = <span class="string">"unknown"</span><span class="comment">;</span>
}
</code></pre>
<h2 id="toc_9">암묵적 캐스팅 피하기</h2>
<p>false 0, &quot;&quot; 0 이 모두 true가 되기 때문에
암묵적 캐스팅으로 인한 혼동을 막기 위해 완전항등연산자인 ===, !== 연산자 만을 사용한다. </p>
<h2 id="toc_10">evel()은 보안문제로 무조건 피하라!</h2>
<p>setInterval(), setTimeout(), Function() 생성자에 문자열을 넘기는 것도 eval()처럼 문제가 발생할 수 있으므로 피한다.</p><pre><code class="javscript"><span class="keyword">var</span> property = <span class="string">"name"</span>;
alert(<span class="keyword">eval</span>(<span class="string">"obj."</span> + property)); <span class="comment">//안티패턴</span>
setTimeout(<span class="string">"myFunc()"</span>, <span class="number">1000</span>); <span class="comment">//안티패턴</span>
setTimeout(<span class="string">"myFunc(1, 2, 3)"</span>, <span class="number">1000</span>); <span class="comment">//안티패턴</span>
</code></pre><p>만약 eval()을 사용해야하는 경우가 발생한다면 new Function(); 을 고려하자. eval()은 유효범위 체인에 간섭을 일으킬 수 있는 단점이 있는 반해, Function은 좀더 봉인 되어 있다. new Function()과 Function()은 동일하다. </p>
<h2 id="toc_11">parseInt()를 통한 숫자 변환</h2>
<p>문자를 숫자로 바꾸는 방법은 parseInt(&quot;05&quot;, 10)와 Number(&quot;05&quot;) 방법이 있다. 단, parseInt의 경우 &quot;05&quot;처럼 앞에 0이 있는 경우에는 반드시 두번째 인자가 10(10진수의 의미)이 되어야 한다. 하지만 Number는 상관없다. Number의 경우 &quot;05 hello&quot;등은 바꿀 수 없고 NaN처리 되지만 parseInt()는 5가 잘 나온다. </p>
<h2 id="toc_12">코딩규칙</h2>
<p>적절한 들여쓰기 사용
중괄호는 생략할 수 있어도 꼭 쓸 것
중괄호 여는 위치는 &quot;세미콜론 삽입 장치&quot; 문제로 반드시 아래처럼 쓰는게 좋다.</p><pre><code class="javscript"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="cell">{
        name: "Batman"
    }</span>;
}
</code></pre><p>공백은 코드가 숨쉴 수 있게하는 요소. 하지만 코드 컨벤션에 따라서 쓰면 되겠다.</p>
<h2 id="toc_13">명명규칙</h2>
<p>생성자는 대문자로 시작
단어 구분에는 낙타표기법(camel case) 사용 - 단 생성자는 대문자 낙타표기법은 함수는 소문자 낙타표기법을 사용한다.
상수는 대문자와 <em>를 적절히 사용한다.
private나 protected는 _</em>myPrivateMethod, _myProtectedMethod 처럼 구분하도록 하자.</p>
<h2 id="toc_14">주석 작성</h2>
<p>YUIDoc(<a href="http://yuilibrary.com/projects/yuidoc">http://yuilibrary.com/projects/yuidoc</a>), JSDoc(<a href="http://code.google.com/p/jsdoc-toolkit">http://code.google.com/p/jsdoc-toolkit</a>) 활용 </p>
<h2 id="toc_15">출시단계 압축</h2>
<p>야후의 YUICompressor 나 구글의 Closure Compiler 활용. </p>
<h2 id="toc_16">JSLint 실행</h2>
<p>지금까지 다룬 패턴 위반사례를 잡아줌. </p>
<h1 id="toc_17">리터럴과 생성자</h1>
<p>이 장에서 중요한 것은 생성자 사용을 자제하고 리터럴 표기법을 사용하라는 것임!</p><p>리터럴 표기법이 생성자 함수 사용보다 더 간결하고 짧다.
리터럴 표기법을 사용하면 유효범위 판별 작업이 발생하지 않는다.
리터럴 표기법을 사용하는 것이 더 안정적이다. new Object()에 인자가 동적으로 전달되는 경우 예기치 않는 결과가 나올 수 있다. var o = new Object(1);에서 o.constructor === Number는 true가 된다.
생성자는 함수내에 반환문이 없더라도 암묵적으로 this를 반환한다. 이 말은 this대신 다른 것도 반환할 수 있다는 것을 의미한다.
생성자 패턴을 사용하면 논리적 오류가 발생할 수 있다. 자바스크립트에서 생성자는 함수일 뿐이므로 new를 빼먹으면 생성자 내부에 this는 전역 객체를 가리키게 되어 의도치 않는 결과를 초래할 수 있다. 이를 우회하기 위해 다음과 같은 패턴을 사용한다.</p><pre><code class="javascript"><span class="function"><span class="title">if</span><span class="params">(typeof <span class="variable">Array</span>.is<span class="variable">Array</span> === <span class="string">"undefined"</span>)</span> {
    A<span class="title">rray</span>.<span class="title">isArray</span> = <span class="title">function</span><span class="params">(arg)</span> {
    <span class="title">return</span> O<span class="title">bject</span>.<span class="title">prototype</span>.<span class="title">toString</span>.<span class="title">call</span>.<span class="params">(arg)</span> === "[<span class="title">object</span> A<span class="title">rray</span>]";
    };
}
</code></pre><p>JSON은 자바스크립트 객체 표기법으로 데이터 전송 형식의 일종으로 배열과 객체 리터럴 표기법의 조합이다.
JSON을 다루기 위해 eval()을 사용하는 것은 금지한다.
JSON은 가능하면 JSON.parse()와 JSON.stringify()를 사용한다. 이것은 ES 5 부터 추가되었다. 구형 브라우져인 경우 YUI나 jQuery용을 사용하자.
정규 표현식도 리터럴 타입이 안전하다. 생성자 타입(new RegExp())을 사용하는 것은 매칭시킬 패턴을 미리 알 수 없어 런타임에 문자열을 만들어야하는 경우이다.
원시 데이터 타입 레퍼 생성자는 사용하지 말자. 즉 new String(&quot;my string&quot;); 이런거 말이다.
원시 데이터에서 &quot;Hello there&quot;.split(&#39; &#39;)[0]; 이 동작할 수 있는 것은 일시적으로 객체로 변환하기 때문이다.
에러 객체. 자바스크립트 에러 객체는 Error(), SyntaxError(), TypeError() 3개이다. 이것은 throw문과 사용된다. 중요한 프로퍼티는 name, message이다. 하지만 throw문은 이 에러 객체를 사용하지 않아도 잘 동작한다. throw {name:.., message:..., extra:...}; 형태처럼 사용해도 무방하다.
다음은 권장되는 리터럴과 원시 데이터 타입이다.</p><pre><code class="javascript"><span class="keyword">var</span> o = {};
<span class="keyword">var</span> a = [];
<span class="keyword">var</span> re = <span class="regexp">/[a-z]/g</span>;
<span class="keyword">var</span> s = <span class="string">""</span>;
<span class="keyword">var</span> n = <span class="number">0</span>;
<span class="keyword">var</span> b = <span class="literal">false</span>;
<span class="keyword">throw</span> {
    name : <span class="string">"Error"</span>,
    message : <span class="string">"uh-oh"</span>
};

또는
<span class="keyword">throw</span> Error(<span class="string">"uh-oh"</span>);
</code></pre>
<h1 id="toc_18">함수</h1>

<h2 id="toc_19">자바스크립트에서 함수의 중요한 특징</h2>
<p>함수는 일급객체 : 값이 전달될 수 있고 프로퍼티와 메서드를 확장할 수 있다.
함수는 지역 유효범위 제공 : 함수외에 다른 중괄호({}) 묶음은 지역 유효범위를 제공하지 않는다. 로컬 변수의 선언은 로컬 유효범위의 맨 윗부분으로 호이스팅이 된다.</p>
<h2 id="toc_20">함수를 생성하는 문법</h2>
<p>기명 함수 표현식(named function expression)</p><pre><code class="javascript"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a + b;
};
</code></pre><p>무명 함수 표현식(unnamed function expression) = 함수 표현식 , 익명함수(anonymous function)</p><pre><code class="javascript"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a + b;
};

함수 선언문(<span class="function"><span class="keyword">function</span> <span class="title">declaration</span>) 함수 선언문에는 세미콜론이 필요하지 않다.
~~~<span class="title">javascript</span>
<span class="title">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="comment">// 함수 본문</span>
}
</code></pre>
<h2 id="toc_21">함수 호이스팅</h2>
<p>함수 선언문은 함수 내에서 호이스팅되지만 함수표현식에서 선언만 호이스팅된다. 즉, 정의는 호이스팅되지 않는다! </p>
<h2 id="toc_22">함수패턴 : API 패턴</h2>
<p>함수에 더 좋고 깔끔한 인터페이스를 제공할 수 있도록 도와줌
콜백 패턴 : 함수를 인자로 전달</p>
<ul>
<li>콜백을 사용할 때는 항상 유효범위를 고려해야한다.</li>
<li>콜백은 라이브러리에 들어가는 코드와 같이 범용적이고 재사용할 수 있도록 일반화 시키는데 도움을 준다.</li>
<li>이벤트와 같이 비동기적 동작을 위해 콜백은 유용하게 사용된다.
설정 객체 : 함수에 많은 수의 매개변수를 전달할 때 통제를 벗어나지 않도록 해줌</li>
<li>좀 더 깨끗한 API를 제공하는 방법으로 라이브러리나 다른 프로그램에서 사용할 코드를 만들 때 유용하다.</li>
<li>장점 : 매개변수와 순서를 기억할 필요 없다. 선택적인 매개변수를 안전하게 생략가능. 읽기 쉽고 유지보수 편함. 매개변수를 추가하거나 제거하기 편함 </li>
<li>단점 : 매개변수 이름을 기억해야함. 프로퍼티 이름들이 압축되지 않음.
함수 반환 : 함수의 반환값이 또 다시 함수가 될 수 있다.</li>
<li>클로저가 생성되기 때문에 비공개 데이터 저장을 위해 사용할 수 있다. 가령, 매번 호출할 때마다 값을 증가시키는 카운터 기능을 만들 수 있다.
커링 : 원본 함수와 매개변수 일부를 물려받는 새로운 함수를 생성한다. </li>
<li>함수 적용 : 함수의 호출은 실제로 인자의 묶음을 함수에 적용하는 것이다. Function.prototype.apply(), Function.prototype.call() 을 기억하자. </li>
<li>부분 적용 : 자바스크립트의 동적인 특성을 사용해 add(5,4)를 add(5)(4) 처럼 동작하도록 한 것을 부분 적용이라고 한다.</li>
<li>커링(Curring) : 부분 적용을 이해하고 처리할 수 있도록 만들어나가는 과정을 말한다. </li>
</ul>
<pre><code class="javascript"><span class="comment">//커링된 add() 예</span>
<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">"undefined"</span>) {
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(y)</span> {</span>
        <span class="keyword">return</span> x + y;
        };
    }
    <span class="keyword">return</span> x + y;
}
<span class="keyword">typeof</span> add(<span class="number">5</span>); <span class="comment">//function</span>
add(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">//7</span>
<span class="keyword">var</span> add2000 = add(<span class="number">2000</span>);
add2000(<span class="number">10</span>); <span class="comment">//2010</span>
</code></pre><pre><code class="javascript"><span class="comment">//커링의 범용성 적용</span>
<span class="function"><span class="keyword">function</span> <span class="title">schonfinkelize</span><span class="params">(fn)</span> {</span>
    <span class="keyword">var</span> slice = Array.prototype.slice,
    stored_args = slice.call(arguments, <span class="number">1</span>);
    <span class="keyword">return</span> <span class="keyword">function</span>() {
        <span class="keyword">var</span> new_args = slice.call(arguments),
            args = stored_args.concat(new_args);
        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);  
    };
}
<span class="comment">//일반함수</span>
<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> {</span>
    <span class="keyword">return</span> x + y;
}
<span class="keyword">var</span> newadd = schonfinkelize(add, <span class="number">5</span>);
newadd(<span class="number">4</span>); <span class="comment">//9</span>

schonfinkelize(add, <span class="number">6</span>)(<span class="number">7</span>); <span class="comment">//13</span>

<span class="comment">//다른 일반함수</span>
<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b, c, d, e)</span> {</span>
    <span class="keyword">return</span> a + b + c + d + e;
}
schonfinkelize(add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">5</span>, <span class="number">5</span>); <span class="comment">//16</span>

<span class="comment">//2단계 커링</span>
<span class="keyword">var</span> addOne = schonfinkelize(add, <span class="number">1</span>);
addOne(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">//41</span>
<span class="keyword">var</span> addSix = schonfinkelize(addOne, <span class="number">2</span>, <span class="number">3</span>);
addSix(<span class="number">5</span>, <span class="number">5</span>); <span class="comment">//16</span>
</code></pre>
<h2 id="toc_23">함수패턴 : 초기화 패턴</h2>
<p>웹페이지와 애플리케이션에서 매우 흔히 사용되는 초기화와 설정작업을 전역 네임스페이스를 어지럽히지 않고 임시 변수를 사용해 좀더 깨끗하고 구조화된 방법으로 수행할 수 있도록 도와줌
즉시 실행 함수 : 정의되자마자 실행된다.</p>
<ul>
<li>장점 : 초기화 코드에 유효범위 샌드박스(sandbox)를 제공한다. 즉, 전역 네임스페이스를 깨끗하게 유지한다.</li>
<li>인자를 전달할 수 있다. 즉시 실행 함수내에서 window를 사용하지 않고도 전역객체에 접근할 때 유용하다.</li>
<li>즉시 실행함수에서 미리 계산하여 클로저에 저장해둔 값을 반환할 수 있다.</li>
<li>객체 프로퍼티를 정의할 때도 사용할 수 있다.
즉시 객체 초기화 : 익명 객체 내부에서 초기화 작업을 구조화한 다음 즉시 호출할 수 있는 메서드를 제공한다.</li>
<li>즉시 객체 초기화 패턴을 활용하면 즉시 실행 함수와 초기화 작업을 할 수 있다는 장점이 있다. 구조적으로 초기화를 구분할 경우 장점이 있다. </li>
<li>하지만 압축도구는 구글의 클러저 컴파일러의 고급 모드에서만 압축이 가능하다.
초기화 시점의 분기 : 최초 코드 실행 시점에 코드를 분기하여, 애플리케이션 생명 주기 동안 계속해서 분기가 발생하지 않도록 막아준다. </li>
<li>어떤 조건이 프로그램의 생명주기 동안 변경이 되지 않는게 확실한 경우, 조건을 단 한 번만 확인하는 것이 바람직하다. </li>
</ul>

<h2 id="toc_24">함수패턴 : 성능 패턴</h2>
<p>코드의 실행속도를 높이는데 도움을 준다.
메모이제이션 패턴 : 함수 프로퍼티를 사용해 계산된 값을 다시 계산되지 않도록 한다. </p>
<ul>
<li>객체의 인자를 캐시하여 키값으로 삼아 같은 인자가 들어올 때 다시 계산하지 않도록 해서 성능을 높혀준다.
자기선언 함수 : 자기 자신을 덮어씀으로써 두 번째 호출 이후부터는 작업량을 줄게 해줌 </li>
<li>함수가 어떤 초기화 준비 작업을 단 한 번만 수행할 경우 유용하다.</li>
<li>단점1은 자기 자신을 재정의한 후에는 이전에 원본 함수에 추가했던 프로퍼티들을 모두 찾을 수 없게된다. </li>
<li>단점2는 함수가 다른 이름으로 사용된다면, 재정의된 부분이 아니라 원본 함수의 본문이 실행되어 의도치 않은 동작을 만들 수 있다.</li>
</ul>

<h1 id="toc_25">객체 생성 패턴</h1>
<p>자바스크립트에서는 객체 리터럴이나 생성자 함수를 사용하여 쉽게 객체를 만들 수 있다. 
자바스크립트는 네임스페이나, 모듈패키지, 비공개 프로퍼티, 스태틱 맴버 등에 대한 문법이 없기 때문에 이러한 기능을 구현하거나 대체하는 범용적인 패턴이 존재한다. </p>
<h2 id="toc_26">네임스페이스 패턴</h2>
<p><em class="label "><strong>장점</strong></em>
전역 공간을 깨끗하게 유지하고 코드를 구조화하여 정리를 도와주는 패턴.</p><p><em class="label "><strong>사용법</strong></em>
전역 네임스페이스의 객체의 이름은 애플리케이션 이름이나 라이브러리의 이름, 도메인명, 회사 이름중 선택해서 사용한다.
눈에 띄기 쉽도록 전역 객체 이름은 모두 대문자로도 사용한다.</p><p><em class="label "><strong>단점</strong></em>
모든 변수와 함수에 접두어를 붙여야 하므로 전체적으로 코드량이 늘어남
전역 인스턴스가 하나뿐이므로 코드의 어느 한부분이 수정되면 전역 인스턴스를 수정하게 된다.
이름이 중첩되고 길므로 프로퍼티 판별하기 위한 검색 작업이 느리다. (샌드박스 패턴으로 해결)</p><p><em class="label "><strong>범용 네임스페이스 함수</strong></em></p><pre><code class="javascript"><span class="keyword">var</span> MYAPP = MYAPP || {};

MYAPP.ns = <span class="function"><span class="keyword">function</span> <span class="params">(ns_string)</span> {</span>
    <span class="keyword">var</span> parts = ns_string.split(<span class="string">'.'</span>);
    <span class="keyword">parent</span> = MYAPP,
    i;
    <span class="comment">// 처음에 중복되는 적역 객체명은 제거</span>
    <span class="keyword">if</span>( parts[<span class="number">0</span>] === <span class="string">'MYAPP'</span> ){
        parts = parts.slice(<span class="number">1</span>);
    }
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parts.length; i += <span class="number">1</span>) {
<span class="keyword">if</span> ( typeof <span class="keyword">parent</span>[parts[parts[i]] === <span class="string">"undefined"</span>) {
<span class="keyword">parent</span>[parts[i]] = {};
}
<span class="keyword">parent</span> = <span class="keyword">parent</span>[parts[i]];
}
<span class="keyword">return</span> <span class="keyword">parent</span>;
};

<span class="comment">//반환 값을 지역변수에 할당</span>
<span class="keyword">var</span> module2 = MYAPP.ns(<span class="string">'MYAPP.modules.modules2'</span>);
modules2 === MYAPP.modules.modules2; <span class="comment">//true</span>

<span class="comment">//첫 부분의 'MYAPP' 생략가능</span>
MYAPP.ns(<span class="string">'modules.modules51'</span>);
</code></pre>
<h2 id="toc_27">의존 관계 선언</h2>
<p>네임스페이스를 지정하여 모듈화함으로써 필요한 모듈만 골라서 쓸 수 있게 되었다. 모듈 사용시 함수나 모듈 내 최상단에, 의존 관계에 있는 모듈을 지역변수로 그 모듈을 가리키도록 선언하는 것이 좋다. </p><p><em class="label "><strong>사용법</strong></em></p><pre><code class="javascript"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//의존 관계가 있는 모듈들</span>
    <span class="keyword">var</span> event = YAHOO.util.Event,
        dom = YAHOO.util.Dom;
    <span class="comment">//이제 event, dom을 사용</span>
};
</code></pre><p><em class="label "><strong>장점</strong></em></p>
<ul>
<li>의존 관계가 명시적이다.</li>
<li>지역변수로 했기 때문에 전역변수와 중첩 프로퍼티 탐색에서 속도적 이익이 있다.</li>
<li>지역변수명은 압축도구(YUICompressor, Google Closure)등으로 축약된다.</li>
</ul>

<h2 id="toc_28">비공개 프로퍼티와 메서드</h2>
<p>자바스크립트는 프로퍼티를 공개권한을 설정할 수 있는 명령이 존재하지 않고 기본적으로 모두 public이 된다.</p><p><em class="label "><strong>비공개(private) 맴버</strong></em> 
클로저를 사용하여 비공개 맴버를 구현할 수 있다. </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span><span class="params">()</span> {</span>
    <span class="comment">//비공개 맴버(외부에서 지역변수를 접근할 수 없으므로)</span>
    <span class="keyword">var</span> name = <span class="string">'iPad'</span>;
    <span class="comment">//공개된 함수</span>
    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> name;
    }
}
<span class="keyword">var</span> toy = <span class="keyword">new</span> Gadget();
console.log(toy.name); <span class="comment">//undefined</span>
console.log(toy.getName()); <span class="comment">//iPad</span>


***특권(privileged) 메서드***
비공개 멤버에 접근권한을 가진 공개 메서드를 가리키는 이름이다. 위 예제에서는 getName() 메서드가 그렇다.

***비공개 멤버의 허점***
특권 메서드에서 비공개 변수의 값을 반환할 경우 이 변수가 객체나 배열이라면 값이 아닌 참조가 반환되므로 외부 코드에서 비공개 변수값을 수정할 수 있다는 허점이 존재한다.
허점을 피하기 위해 최소 권한의 원칙(principle of Least Authority, POLA)를 적용하여 필요 이상의 권한을 주지않도록 한다. 가령 일부 데이터만 반환하던가, 객체를 복사해서 반환하던가 하는 방식을 취한다. 

***객체 리터럴과 비공개 맴버*** 
비공개 맴버를 만드는데 생성자 방법 뿐 아니라 리터럴로도 만들 수 있다. 즉, 익명 즉시 실행 함수를 추가하여 클로저를 만들면 되겠다. 이것은 모듈 패턴의 기초가 된다. 

~~~javascript
<span class="keyword">var</span> myobj = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//비공개 멤버</span>
    <span class="keyword">var</span> name = <span class="string">"my, oh my"</span>;

    <span class="comment">//공개될 부분을 구현</span>
    <span class="keyword">return</span> {
        getName : <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> name;
        }
    };
}());
myobj.getName(); <span class="comment">//my, oh my</span>
</code></pre>
<h2 id="toc_29">프로토타입과 비공개 맴버</h2>
<p>생성자를 사용해 비공개 맴버를 만들 경우, 생성자를 호출하여 새로운 객체를 만들 때마다 비공개 멤버가 매번 재생성되어 메모리 낭비가 생긴다.
그러므로 메모리를 절약하기 위해 공통 프로퍼티와 메서드를 생성자의 프로토타입에 추가해야 한다. </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span><span class="params">()</span> {</span>
    <span class="comment">// 비공개 맴버</span>
    <span class="keyword">var</span> name = <span class="string">'iPod'</span>;
    <span class="comment">// 공개 함수</span>
    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> name;
    };
}
Gadget.prototype = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">// 비공개 멤버</span>
    <span class="keyword">var</span> browser = <span class="string">"Mobile Webkit"</span>;
    <span class="comment">// 공개된 프로토타입 맴버</span>
    <span class="keyword">return</span> {
        getBrowser: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> browser;
        }
    };
}());

<span class="keyword">var</span> toy = <span class="keyword">new</span> Gadgets();
console.log(toy.getName());  <span class="comment">// 객체 인스턴스의 특권 메서드</span>
console.log(toy.getBrowser());  <span class="comment">///프로토타입의 특권 메서드</span>
</code></pre><p><em>**비공개 함수를 공개 메서드로 노출하는 방법 *</em>*
노출 패턴(revelation pattern)은 비공개 메서드를 구현하면서 동시에 공개 메서드로도 노출하는 것을 의미. 비공개 함수를 안전하게 보호해줌 </p><pre><code class="javascript"><span class="keyword">var</span> myarray;
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//비공개 맴버</span>
    <span class="keyword">var</span> astr = <span class="string">"[object Object]"</span>,
        toString = Object.prototype.toString;

    <span class="comment">//비공개 함수</span>
    <span class="function"><span class="keyword">function</span> <span class="title">isArray</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> toString.call(a) === astr;
    }

    <span class="comment">//비공개 함수</span>
    <span class="function"><span class="keyword">function</span> <span class="title">indexof</span><span class="params">(haystack, needle)</span> {</span>
        ....
    }

    myarray = {
        isArray : isArray,
        indexOf: indexOf,
        inArray: indexOf
    };
}());

myarray.indexOf = <span class="literal">null</span>;
myarray.inArray([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"z"</span>], <span class="string">"z"</span>); <span class="comment">//2</span>
</code></pre><p>이처럼 결과가 나오는 것은 비공개 함수는 보호되기 때문이다. </p>
<h2 id="toc_30">모듈패턴</h2>

<ul>
<li>모듈 패턴은 늘어나는 코드를 구조화 하고 정리하는데 도움이 되고 널리 쓰인다.</li>
<li>이 패턴을 사용하면 개별적인 코드를 느슨하게 결합시킬 수 있다.</li>
<li>모듈 패턴은 특히 점점 늘어만 가는 코드를 정리할 때 널리 사용되며 매우 추천하는 방법이다.</li>
<li>모듈 패턴은 네임스페이스 패턴, 즉시 실행 함수, 비공개 맴버와 특권 맴버, 의존 관계 선언, 노출 패턴등이 섞인 패턴이다.</li>
</ul>
<pre><code class="javascript"><span class="comment">//네임스페이스 패턴 적용</span>
MYAPP.ns(<span class="string">'utilities.array'</span>);

<span class="comment">//즉시실행함수</span>
MYAPP.utilities.<span class="keyword">array</span> = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//의존 관계 선언</span>
    <span class="keyword">var</span> uobj = MYAPP.utilities.object,
        ulang = MYAPP.utilities.lang;
    <span class="comment">//비공개 프로퍼티</span>
    <span class="keyword">var</span> array_string = <span class="string">"[object Array]"</span>,
    ops = Object.prototype.toString,

    <span class="comment">///비공개 매서드(특권 메서드)</span>
    inArray = <span class="function"><span class="keyword">function</span> <span class="params">(haystack, needle)</span> {</span>
    },
    isArray = <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> {</span>
    };

<span class="comment">//공개 API 노출(노출패턴 적용)</span>
    <span class="keyword">return</span> {
        isArray: isArray,
        indexof: inArray
    };
}());
</code></pre><p><em class="label "><strong>생성자를 생성하는 모듈</strong></em>
앞선 예제는 MYAPP.utilities.array 라는 객체를 만들었지만 생성자 함수를 사용해 객체를 만드는게 더 편할 수 있다.</p><pre><code class="javascript">MYAPP.ns(<span class="string">'MYAPP.utilities.Array'</span>);
MYAPP.utilities.Array = (<span class="keyword">function</span> () {
    //의존 관계 선언
    var uobj = MYAPP.utilities.object,
        ulang = MYAPP.utilities.lang;
    // 비공개 프로퍼티와 메서드 선언 후<span class="keyword">...</span>
        Constr;
    //var 선언 마침

    //공개 API - 생성자 함수
    Constr = <span class="keyword">function</span> (o) {
        this.elements = this.toArray(o);
    };
    //공개 API - 프로토타입
    Constr.prototype = {
        constructor: MYAPP.utilities.Array,
        version: <span class="string">"0"</span>,
        toArray : <span class="keyword">function</span>(obj) {
        <span class="keyword">...</span>
        };
    };

    //생성자 함수를 반환
    //이 함수가 새로운 네임스페이스에 할당될 것이다.
    <span class="keyword">return</span> Constr;
}());
var arr = new MYAPP.utilities.Array(obj);
</code></pre><p><em class="label "><strong>모듈에 전역 변수 가져오기</strong></em>
보통 전역변수에 대한 참조 또는 전역 객체 자체를 전달한다. 이렇게 하면 좀더 탐색이 빨라짐 </p><pre><code class="javascript"><span class="transposed_variable">MYAPP.</span><span class="transposed_variable">utilities.</span>module = (<span class="function"><span class="keyword">function</span> <span class="params">(app, global)</span> {</span>
}(MYAPP, this));
</code></pre>
<h2 id="toc_31">샌드박스 패턴</h2>
<p>다음 네임스페이스의 단점을 해결한다.</p>
<ul>
<li>애플리케이션 전역 객체가 단 하나의 전역변수에 의존</li>
<li>항상 긴 이름을 써야해서 런타임시 탐색 과정을 거쳐야 함.</li>
<li>다음과 같은 인터페이스에 대응한다.</li>
</ul>
<pre><code class="javascript">Sandbox([<span class="string">'ajax'</span>, <span class="string">'event'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> {</span>
    <span class="comment">// console.log(box);</span>
});

Sandbox(<span class="string">'ajax'</span>, <span class="string">'event'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> {</span>
    <span class="comment">// console.log(box);</span>
});

Sandbox(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> {</span>
    <span class="comment">// console.log(box);</span>
});

Sandbox(<span class="function"><span class="keyword">function</span> <span class="params">(box)</span> {</span>
    <span class="comment">// console.log(box);</span>
});

Sandbox(<span class="string">'dom'</span>, <span class="string">'event'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> {</span>
    Sandbox(<span class="string">'ajax'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> {</span>
    });
});
</code></pre><p>샌드박스 패턴을 사용하면 콜백 함수로 코드를 감싸기 때문에 전역 네임스페이스를 보호할 수 있다.</p>
<h2 id="toc_32">스태틱 맴버</h2>
<p>자바스크립트는 스태틱 맴버를 만들기 위해 별도의 패턴이 필요하다.</p>
<ul>
<li>스태틱 맴버는 공개와 비공개 맴버가 있다.</li>
<li>특정 인스턴스에 한정되지 않는 메서드와 데이터를 담을 수 있고 인스턴스별로 매번 생성하지 않는다.</li>
<li>비공개 스태틱 맴버는 싱글턴 패턴을 다룰 때 사용된다.</li>
</ul>

<h2 id="toc_33">객체 상수</h2>
<p>자바스크립트는 상수는 없지만 값을 한번 설정하면 변경되지 않도록 만들 수 있다. </p>
<h2 id="toc_34">체이닝 패턴</h2>
<p>채이닝 패턴이란 객체에 연쇄적으로 메서드를 호출할 수 있도록 하는 패턴이다. 아이디어는 this를 반환한다. 
myobj.method&quot;hello&quot;).method).method&quot;world&quot;).method);</p><p>체이닝 패턴의 장단점</p>
<ul>
<li>코드량이 줄고 코드가 간결해진다.</li>
<li>작고 특화된 함수를 만들어 유지보수에 도움이 된다.</li>
<li>하지만 디버깅이 어렵다.</li>
</ul>

<h2 id="toc_35">method() 메서드</h2>
<p>아래처럼 체이닝 패턴을 이용해 method를 등록할 수 있게 한다. 이때 인스턴스 맴버가 아닌 프로토타입에 등록시키기 위해 method는 그 아래 코드처럼 구현한다. </p><pre><code class="javascript"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
    <span class="keyword">this</span>.name = name;
}.method(<span class="string">'getName'</span>, <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
}).method(<span class="string">'setName'</span>, <span class="keyword">function</span>(name) {
    <span class="keyword">this</span>.name = name;
    <span class="keyword">return</span> <span class="keyword">this</span>;
});
</code></pre><p>method는 아래처럼 구현한다. 결국 Function의 프로토타입에 method가 만들어져 확장된다.</p><pre><code class="javascript"><span class="title">if</span>( <span class="typedef">typeof <span class="type">Function</span>.prototye.method !== "function") <span class="container">{
    <span class="type">Function</span>.<span class="title">prototype</span>.<span class="title">method</span> = <span class="title">function</span> (<span class="title">name</span>, <span class="title">implementattion</span>) {
        <span class="title">this</span>.<span class="title">prototype</span>[<span class="title">name</span>] = <span class="title">implementation</span>;
        <span class="title">return</span> <span class="title">this</span>;
    }</span>;</span>
}
</code></pre>
<h1 id="toc_36">코드 재사용 패턴#1</h1>
<p><em>**클래스 방식 vs 새로운 방식의 상속 패턴 *</em>*</p><p>대다수의 프로그래밍 언어는 객체의 설계도로 클래스 개념이 있지만 자바스크립트에서는 클래스가 없다.
자바스크립트의 객체는 단순히 키-값의 쌍일뿐이며 언제든지 생성하고 변경할 수 있다. 
클래스가 없기 때문에 다른 패턴으로 상속을 구현할 수 있다. 함수와 프로토타입, 클로저등의 개념을 적절히 섞는다면 다른 언어의 클래스및 상속패턴등을 흉내낼 수 있다. 
하지만 자바스크립트는 그 특성상 코드재사용을 위해 꼭 클래스 상속 개념을 사용할 필요가 없다. 그 외에 다양한 방법으로 사용할 수 있기 때문에 
이런 클래스 방식으로 상속을 구현하지 않고 새로운 방식으로 발전시킬 수 있다. 이 장에서는 먼저 전통적인 클래스 방식으로 코드 재사용을 알아보고
자바스크립트의 특징을 살린 새로운 방식으로의 재사용 패턴을 소개하고 있다. 클래스 상속이 필요없다고 해서 소홀히 보면 안된다.
이 부분을 잘 봐두면 자바스크립트의 함수, 프로토타입, 클로저 개념들의 활용을 더 명확히 학습할 수 있기 때문이다. </p>
<h2 id="toc_37">클래스 방식의 상속 패턴 #- 기본 패턴</h2>
<p>자바스크립트는 상속을 직접적으로 지원하지 않기 때문에 모두 구현해야한다. 클래스 방식이라고 하지만 클래스가 없고 생성자 함수만 있을 뿐이다. </p><pre><code class="javascript"><span class="comment">//상속을 담당해 주는 함수</span>
<span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> {</span>
    C.prototype = <span class="keyword">new</span> P();
}

<span class="comment">//부모 생성자</span>
<span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">(name)</span> {</span>
    <span class="keyword">this</span>.name = name || <span class="string">'jidolstar'</span>;
}

<span class="comment">//생성자의 프로토타입에 기능을 추가</span>
<span class="keyword">Parent</span>.prototype.say = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
}

<span class="comment">//아무 내용이 없는 자식 생성자 </span>
<span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">(name)</span> {</span>}

<span class="comment">//여기서 상속이 일어남</span>
inherit(Child, <span class="keyword">Parent</span>);

<span class="comment">//아래처럼 사용</span>
<span class="keyword">var</span> kid = <span class="keyword">new</span> Child();
kid.say(); <span class="comment">//jidolstar</span>

이 패턴은 가장 널리 쓰이는 기본적인 방법으로 <span class="keyword">Parent</span>() 생성자를 사용해 객체를 생성한 다음 이 객체를 Child()의 프로토타입에 할당하는 것이다.
inherit(C, P) 함수가 그것을 담당해주고 있다. 여기서 prototype 프로퍼티가 함수가 아니라 객체를 가리키는 것이 중요하다.
또 <span class="keyword">new</span> 연산자가 있음을 잘 봐두자. 결국 프로토타입 체인에 의해 부모의 인스턴스 기능을 물려받는다.
하지만 이 패턴은 단점이 있다.
부모 객체의 <span class="keyword">this</span>에 추가된 객체 자신의 프로퍼티와 프로토타입 프로토퍼티를 모두 물려받는다.  
이 inherit() 함수는 인자를 처리하지 못한다. 즉, 자식 생성자에 인자가 들어와도 부모 생성자에 전달 못한다.
<span class="keyword">var</span> s = <span class="keyword">new</span> Child(<span class="string">'joykim'</span>);
s.say(); <span class="comment">//여전히 jidolstar</span>
자식 인스턴스를 생성할 때마다 상속을 실행하는데 여기서는 부모 객체를 계속해서 재생성하게 되어 비효율적이다.

<span class="comment">##클래스 방식의 상속 패턴 #- 생성자 빌려쓰기</span>
이 패턴은 자식에서 부모로 인자를 전달하지 못했던 <span class="comment"># 문제를 해결한다. 이 패턴은 부모 생성자 함수의 this에 자식 객체를 바인딩한 다음, 자식 생성자가 받은 인자를 모두 넘겨준다. </span>
<span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">(a, b, c, d)</span> {</span>
<span class="keyword">Parent</span>.apply(<span class="keyword">this</span>, argument);
}
이렇게 하면 부모 생성자 함수 내부의 <span class="keyword">this</span>에 추가된 프로퍼티만 물려받게 된다. 
중요한 것은 부모의 프로퍼티를 부모것을 참조하는게 아니라 부모것에 대한 복사본을 가진다는 점이다.
단, 프로토타입에 추가된 맴버는 상속받지 않는다. 
생성자 빌려쓰기는 프로토타입이 전혀 상속되지 않기 때문에 분명히 한계가 있다. 
반면에 부모 생성자 자신의 맴버에 대한 복사본을 가져올 수 있다는 장점이 있어 자식이 실수로 부모의 프로퍼티를 덮어쓰는 위험은 방지된다. 
생성자 빌려쓰기 패턴은 다중상속도 가능하다. 

<span class="comment">##클래스 방식의 상속 패턴 # 생성자 빌려쓰고 프로토타입 지정해주기</span>
이 패턴은 앞선 두 개의 패턴을 혼용한다. 
~~~javascript
<span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">(a, b, c, d)</span> {</span>
    <span class="keyword">Parent</span>.apply(<span class="keyword">this</span>, argument);
}
Child.prototype = <span class="keyword">new</span> <span class="keyword">Parent</span>();

<span class="comment">//테스트</span>
<span class="keyword">var</span> kid = <span class="keyword">new</span> Child(<span class="string">'joykim'</span>);
kid.name; <span class="comment">//joykim</span>
kid.say(); <span class="comment">//joykim</span>
delete kid.name;
kid.say(); <span class="comment">//jidolstar</span>
</code></pre><p>자식 객체는 부모가 가진 자신만의 프로퍼티 복사본을 가지게 되는 동시에, 부모의 프로토타입 멤버로 구현된 재사용 가능한 기능들에 대한 참조 또한 물려받게 된다.
하지만 부모생성자를 비효율적으로 두 번 호출한다는 것은 단점이다. 
클래스 방식의 상속 패턴 #- 프로토타입 공유 
지금까지의 패턴과는 전혀 다르게 부모생성자를 전혀 호출하지 않는다.   </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> {</span>
    <span class="transposed_variable">C.</span>prototype = <span class="transposed_variable">P.</span>prototype;
}
</code></pre><p>이 패턴은 프로토타입 체인 검색이 짧고 간편해지며 부모가 가진 say() 메서드를 자식에서도 똑같은 접근 권한을 가진다. 
그러나 이 패턴은 상속 체인이 공유되기 때문에  수정될 때 부모, 자식, 프로토타입에 전부 영향이 간다. 그리고 자식 객체는 부모의 name 프로퍼티를 물려받지 않는다.</p>
<h2 id="toc_38">클래스 방식의 상속 패턴 #- 임시 생성자</h2>
<p>이 패턴은 프로토타입 체인의 이점을 유지하면서, 동일한 프로토타입을 공유할 때의 문제점을 해결하도록 부모와 자식의 프로토타입 사이에 직접적인 링크를 끊어버린다. </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> {</span>
    var F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {};</span>
    <span class="transposed_variable">F.</span>prototype = <span class="transposed_variable">P.</span>prototype;
    <span class="transposed_variable">C.</span>prototype = new F();
}
</code></pre><p>여기서 함수 F가 임시 생성자를 프로토콜 타입으로 설정하므로 장점으로 자식 프로토타입이 수정되더라도 부모의 프로토타입에 영향을 주지 않는다. 생성자에서 this에 추가한 멤버는 상속되지 않는다. </p><pre><code class="javascript"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();
</code></pre><p>위 코드에서 kid.name에 접근하면 undefined라는 값을 얻는다. 
name은 부모 자신의 프로퍼티인데 상속과정에서 new Parent()를 호출한 적이 없기 때문에 이 프로퍼티는 생성조차 않는다. 
하지만 kid.say()의 경우 프로토타입 체인에 의해 Parent의 prototype에 정의된 say() 메서드에 접근이 된다. 
이 패턴에 부모 원본에 대한 참조를 추가할 수 있다. 상속체계에서 상위 클래스에 대한 참조를 자식 클래스가 접근하기 위해 super를 이용하듯이 말이다. </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> {</span>
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
    F.prototype = P.prototype;
    C.prototype = <span class="keyword">new</span> F(); <span class="comment">//임시생성자 상속패턴 적용</span>
    C.uber = P.prototype; <span class="comment">//부모 원본에 대한 참조</span>
}
</code></pre><p>또한 상속 함수를 더욱 완벽하게 만들기 위해 한가지 더 설정해야 한다. 
현재 상태에서는 모든 자식 객체들의 생성자는 Parent()로 지정되어 있다. 그러므로 생성자 함수를 자식 자신을 가리킬 수 있도록 아래처럼 코드를 추가한다. </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> <span class="comment">{
    var F = function () {}</span>;</span>
    F.prototype = P.prototype;
    C.prototype = new F(); <span class="comment">//임시생성자 상속패턴 적용</span>
    C.uber = P.prototype; <span class="comment">//부모 원본에 대한 참조</span>
    C.prototype.<span class="function"><span class="keyword">constructor</span> = <span class="title">C</span>;</span> <span class="comment">//자식이 자식의 생성자 함수를 가리키도록 한다.</span>
}
</code></pre><p>최종 버전은 최적화이다. 최적화되는 상속 함수는 상속이 필요할 때마다 임시(프록시) 생성자가 생성되지 않도록 한다. 즉시실행 함수와 클로저를 이용해 최적화 한다. </p><pre><code class="javascript">var inherit = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    var F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {};</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(C, P)</span> {</span>
    <span class="transposed_variable">F.</span>prototype = <span class="transposed_variable">P.</span>prototype;
    <span class="transposed_variable">C.</span>prototype = new F();
    <span class="transposed_variable">C.</span>uber = <span class="transposed_variable">P.</span>prototype;
    <span class="transposed_variable">C.</span><span class="transposed_variable">prototype.</span>constructor = C;
    };
}());
</code></pre>
<h2 id="toc_39">클래스 방식 상속 패턴을 활용한 klass 제작</h2>
<p>아래 klass() 함수는 클래스를 상속을 구현하기 위한 문법 설탕을 제공한다.<br>
함수 대신 Klass()라는 생성자 함수를 사용하거나 Object.prototype을 확장하기도 하는데 여기서는 간단한 함수를 보여주고 있다.</p><pre><code class="javascript"><span class="keyword">var</span> klass = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(Parent, props)</span> {</span>
        <span class="keyword">var</span> Child, i;

        <span class="comment">// 새로운 생성자</span>
        Child = function() {
        <span class="keyword">if</span> (Child.uber &amp;&amp; Child.uber.hasOwnProperty(<span class="string">'__construct'</span>)) {
            console.log(<span class="string">'Child.uber.__construct 적용'</span>);
            Child.uber.__construct.apply(<span class="keyword">this</span>, arguments);
        }
        <span class="keyword">if</span>(Child.prototype.hasOwnProperty(<span class="string">'__construct'</span>)) {
            console.log(<span class="string">'Child.prototype.__construct 적용'</span>);
            Child.prototype.__construct.apply(<span class="keyword">this</span>, arguments);
        }
    };

    <span class="comment">// 상속</span>
    <span class="keyword">Parent</span> = <span class="keyword">Parent</span> || Object;

    F.prototype = <span class="keyword">Parent</span>.prototype;
    Child.prototype = <span class="keyword">new</span> F();
    Child.uber = <span class="keyword">Parent</span>.prototype;
    Child.prototype.constructor = Child;

    <span class="comment">// 구현 메서드를 추가한다.</span>
    <span class="keyword">for</span> (i in props) {
        <span class="keyword">if</span> (props.hasOwnProperty(i)) {
            Child.prototype[i] = props[i];
        }
    }
    <span class="comment">//'클래스'를 반환한다.</span>
    <span class="keyword">return</span> Child;
    };
}());
</code></pre><p>책에서 제공된 소스와는 약간 다르다. 위 klass() 함수는 상속 패턴 #서 소개한 마지막 inherit() 메서드 최적화를 적용했다. 
즉, 즉시실행함수를 사용해 임시(프록시) 생성자 F를 클로저 안에 저장해 한 번만 만들도록 바꾸었다.<br>
아래 코드는 이 klass() 함수를 사용해 Man 생성자 함수를 만드는 예제이다. </p><pre><code class="javascript"><span class="comment">//사람 생성자 함수 생성</span>
<span class="keyword">var</span> Man = klass(<span class="literal">null</span>, {
__construct: <span class="function"><span class="keyword">function</span> <span class="params">(what)</span> {</span>
console.log(<span class="string">'Man\'s constructor'</span>);
<span class="keyword">this</span>.name = what;
},
getName: <span class="keyword">function</span>() {
<span class="keyword">return</span> <span class="keyword">this</span>.name;
}
});

<span class="comment">//사람 객체</span>
<span class="keyword">var</span> first = <span class="keyword">new</span> Man(<span class="string">'Adam'</span>);
console.log(first.getName());
</code></pre><p>사람 로그는 다음과 같이 찍힌다. </p><p>Man 생성자 함수의 경우 상속받는 대상이 없기 때문에 Object가 부모가 되며 
_<em>construct와 getName 메서드가 Man의 프로토타입에 추가된다. 
new Man()을 통해 생성자 내부에 정의된 두개의 if문을 거치게 되는데
일단 첫번째 if문에서 Man.uber는 Object의 프로토타입이므로 null이 된다. 그러므로 무시된다. 
두 번째 if문에서는 Man.prototype에 _</em>construct 메서드가 추가되었으므로 이 if문 내부는 실행된다.
여기서 상속 패턴 #생성자 빌려쓰기 패턴이 적용되어 __construct() 메서드 내부에 this는 Man 객체(first)를 가리키게 된다.
그러므로 Man 객체에서 getName()을 호출하면 this.name은 바로 Adam이 되는 것이다. </p><p>Child.prototype._<em>construct 적용
Man&#39;s constructor
Adam
이제 사람 생성자 함수(Man)를 상속받는 슈퍼맨 생성자 함수를 만들자. Man과 차이점은 자식 생성자 함수인 Man을 인자로 넘긴것과 getName()에서  return this.name이 아닌 SuperMan.uber.getName()을 호출했다는 점이다. 하지만 여기서 this.name에서 this는 이미 SuperMan 객체의 자신을 가리키도록 klass() 함수 내부에 Child 생성자 함수 안 첫번째 if문에 this를 넘겼음을 상기하자. 결국 this.name은 SuperMan 객체의 프로퍼티인 셈이다. 
//슈퍼맨 생성자 함수 생성
var SuperMan = klass(Man, {
_</em>construct: function (what) {
console.log(&#39;SuperMan\&#39;s constructor&#39;);
},
getName: function () {
var name = SuperMan.uber.getName.call(this);
return &#39;I am &#39; + name;
}
});</p><p>//슈퍼맨 객체
var clark = new SuperMan(&#39;Clark Kent&#39;);
console.log(clark.getName());
다음은 위 코드를 실행했을 때 로그이다. 이번에는 Man을 상속했기 때문에 klass()함수의 Child 생성자 함수 내부에 첫 번째 if문 내부가 실행된다. 그래서 SuperMan에는 name 프로퍼티를 구현한 적이 없지만 Man에 구현되어 있기 때문에 SuperMan 객체에 name 프로퍼티가 자동으로 등록되게 된다.<br>
Child.uber.<strong>construct 적용
Man&#39;s constructor
Child.prototype.</strong>construct 적용
SuperMan&#39;s constructor
I am Clark Kent
이제 마지막으로 슈퍼맨 객체는 누구의 인스턴스인가 확인해보자.
//슈퍼맨 객체는 누구의 인스턴스인가?
console.log(clark instanceof Man); //true
console.log(clark instanceof SuperMan); //true
간단하지만 이 klass() 함수는 기본적인 클래스 상속을 구현해 냈고 제대로 동작하는 것을 확인할 수 있다. 지금까지 다룬 상속 패턴은 피하는 것이 좋다. 왜냐하면 기술적으로 언어에 존재하지 않는 혼란스러운 개념을 온통 끌고 오기 때문이다. 하지만 이 개념은 확실히 알 필요는 있다. 프로토타입과 클로저등을 사용해 어떻게 상속을 구현하는지 아는 것은 결국 이것들의 유용한 점을 알기에 좋기 때문이다. 이 패턴의 장점은 자바스크립트를 경험해보지 못해 프로토타입이 낮설게 생각하는 개발자들에게 유용할 수 있다.
프로토타입을 사용한 상속과 프로퍼티 복사를 통한 상속, 믹스-인, 메서드 빌려쓰기는 다음에 정리! <sup>^</sup></p><p>프로토타입을 활용한 상속 
프로토타입을 활용한 상속은 클래스를 사용하지 않는 &#39;새로운&#39; 방식의 패턴이다. </p><p>다음과 같은 함수가 이것을 실현시킨다.</p><p>// 프로토타입 활용한 상속을 가능케하는 함수
function object(o) {
function F() {};
F.prototype = o;
return new F();
}
위 함수를 아래처럼 사용할 수 있다.
// 상속할 객체
var parent = {
name: &quot;Papa&quot;,
getName:function() {
return this.name;
}
};
// 새로운 객체
var child = object(parent);
//테스트
console.log(child.name); //&quot;Papa&quot;
console.log(child.getName()); //&quot;Papa&quot;
위 코드처럼 부모를 객체 리터럴로 생성하는 것 뿐만 아니라 생성자 함수를 통해서도 부모를 생성할 수 있다. 
//부모 생성자
function Person() {
// 부모 생성자 자신의 프로퍼티
this.name = &quot;Adam&quot;;
}
// 프로토타입에 추가된 프로퍼티
Person.prototype.getName = function () {
return this.name;
};
// Person 인스턴스 생성
var papa = new Person();
// 이 인스턴스를 상속
var kid = object(papa);
// 부모 자기 자신의 프로퍼티와 프로토타입의 프로퍼티가 모두 상속되었는지 확인
console.log(kid.getName()); //&quot;Adam&quot;
하지만 주의할 것은 생성자 함수의 프로토타입 객체만 상속받게 할 수 있다. 
var kid= object(Person.prototype);
console.log(typeof kidgetName); //&quot;function&quot; 이 메서드는 프로토타입 안에 정의된 프로퍼티이다.
console.log(typeof kidname); //&quot;undefined&quot; 프로토타입만 상속했기 때문에 부모에 정의된 name 프로퍼티는 상속되지 않음
ECMAScript 는 Object.create()가 위 object() 함수를 구현하고 있다. 
var parent = new Person();
var child= Object.create(parent, {
age: { value: } //ECMA 기술자(Descriptor)
});
console.log(childhasOwnProperty(&quot;age&quot;)); //true
자바스크립트 라이브러리에서 YUI서도 Y.Object() 메서드가 그것을 구현하고 있음을 알아두자.
책 내용에는 없지만 위 방식을 그대로 사용하는 것은 부정적이다. 이것은 여전히 전역을 더럽히기 때문에 네임스페이스 패턴이든 샌드박스 패턴이든 사용해 전역을 최소화할 필요가 있겠다. 하지만 기존 클래스 방식의 상속보다 훨씬 간단하면서도 매끄럽게 재사용 패턴을 적용할 수 있다는 점은 크게 매력적이다. 
프로퍼티 복사를 통한 상속패턴 
아래는 얕은 복사 방식이다.
//프로퍼티 얕은 복사를 통한 상속 패턴 적용 함수
function extend(parent, child) {
var i,
child = child || {};
for( i in parent ) {
if( parent.hasOwnProperty(i) ) {
child[i] = parent[i];
}
}
return child;
}</p><p>//프로퍼티 복사 확인
var dad = {name: &quot;Adam&quot;};
var kid = extend(dad);
console.log(kid.name); //&quot;Adam&quot;</p><p>//프로퍼티 얕은 복사 확인
var dad= {
counts: [  ,
reads: {paper: true}
};
var kid= extend(dad;
kidcounts.push(;
console.log(kidcounts.toString()); //&quot;
console.log(dadreads === kidreads); //true
아래 코드는 프로퍼티 깊은 복사를 통한 상속 패턴 적용 함수이다. 
function extendDeep(parent, child) {
var i,
toStr = Object.prototype.toString;
astr = &quot;[object Array]&quot;;
child = child || {};
for (i in parent) {
if (parent.hasOwnProperty(i)){
if (typeof parent[i] === &quot;object&quot;) {
child[i] = (toStr.call(parent[i]) === astr) ? [] : {};
extendDeep(parent[i], child[i]);
} else {
child[i] = parent[i];
}
}
}
return child;
}</p><p>var dad = {
counts: [  ,
reads: {paper: true}
};
var kid = extendDeep(dad);
kid.counts.push(;
console.log(kid.counts.toString()); //&quot;
console.log(dad.counts.toString()); //&quot;
console.log(dad.reads === kid.reads); // false
kid.reads.paper = false;
console.log(dad.reads.paper);  //true
위 함수들은 아주 간단하고 널리 사용된다고 한다. 그리고 jQuery의 extend() 메서드는 깊은 복사를 하고 Y.clone() 깊은 복사를 수행하면서 함수도 복사해 자식 객체와 바인딩 해준다고 한다. 이 패턴은 프로토타입을 전혀 사용하지 않은 것도 주목할 만하다. 
하지만 내 생각에.... 깊은 복사를 하는 과정에서 extendDeep()을 재귀적으로 호출하고 있다. 이 점은 자바스크립트 특성상 이렇게 쓰는 경우 스택오버가 걸릴 가능성이 농후하므로 뭔가 비동기적으로 동작하도록 만들 필요가 있다. 
게다가 배열이 for-in 루프로 요소를 탐색하는 것은  기초에서 다루었듯이 for 루프를 사용하는 것이 맞다. </p>
<h2 id="toc_40">믹스-인</h2>
<p>프로퍼티 복사 아이디어를 발전시켜 믹스-인 패턴을 생각할 수 있다. 이것은 하나의 객체를 복사하는게 아니라 여러 객체를 복사해 하나의 객체에 섞어 넣을 수 있다.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">mix</span><span class="params">()</span> {</span>
    var arg, prop, child = <span class="cell">{}</span>;
    <span class="keyword">for</span> (arg = <span class="number">0</span>; arg &lt; <span class="transposed_variable">arguments.</span><span class="built_in">length</span>; arg +=  <span class="cell">{
        for (prop in arguments[arg]) {
            if (arguments[arg].hasOwnProperty(prop)) { //프로토타입 프로퍼티를 걸러냄
                child[prop] = arguments[arg][prop];
            }</span>
        }
    }
    <span class="keyword">return</span> child;
}
var cake = mix(
    <span class="cell">{eggs:  large: true}</span>,
    <span class="cell">{butter:  salted: true}</span>,
    <span class="cell">{flour: "cups"}</span>,
    <span class="cell">{sugar: "sure!"}</span>
);
<span class="transposed_variable">console.</span>dir(cake);
</code></pre><p>결과적으로 아래처럼 나온다.</p><pre><code class="console"><span class="attribute">butter</span>: <span class="string">1</span>
<span class="attribute">eggs</span>: <span class="string">2</span>
<span class="attribute">large</span>: <span class="string">true</span>
<span class="attribute">salted</span>: <span class="string">true</span>
<span class="attribute">flour</span>: <span class="string">"cups"</span>
<span class="attribute">sugar</span>: <span class="string">"sure!"</span>
</code></pre><p>믹스-인 개념에는 단순히 루프를 돌고, 프로퍼티를 복사하는 것이기 때문에 부모들과의 연결 고리는 끊어진 상태이다. 
개인적인 이 패턴에 대한 생각을 남기면... 위 mix() 메서드는 여러개의 객체중에 프로퍼티 이름이 중복되면 마지막에 들어간 것이 기존에 있는 것을 덮어쓰게 될 것이다. 
게다가 다음과 같은 경우에는 대응하지 못한다.</p><pre><code class="javascript">var a = {array: [}<span class="comment">;</span>
var cake = mix(
    {eggs:  large: true},
    {butter:  salted: true},
    {flour: <span class="string">"cups"</span>},
    {sugar: <span class="string">"sure!"</span>},
    a
)<span class="comment">;</span>
a<span class="preprocessor">.array</span><span class="preprocessor">.push</span>()<span class="comment">;</span>
    console<span class="preprocessor">.log</span>(a<span class="preprocessor">.array</span><span class="preprocessor">.toString</span>())<span class="comment">; //"</span>
    console<span class="preprocessor">.log</span>(cake<span class="preprocessor">.array</span><span class="preprocessor">.toString</span>())<span class="comment">; //"</span>
</code></pre><p>원래 기대하는 바는 cake.array.toString()의 경우 &quot;이어야 할 것이다. 즉, 배열값에 대해서는 얕은 복사를 했으므로 깊은 복사를 할 수 있도록 개선해야한다. </p>
<h2 id="toc_41">메서드 빌려쓰기</h2>
<p>메서드 빌려쓰기 재사용 패턴은 정말 자바스크립트의 특징을 대변해주는 패턴일 것이다.
이 패턴은 부모-자식 관계까지 만들지 않고 어떤 객체의 메서드 한두개만 빌려쓰는데 유용하다. 
책 내용중에는 apply와 call을 사용해 bind를 구축하는 방법과 this문제를 잘 다루었다. 
마지막에 ECMAScript 터 지원하는 Function.prototype.bind() 메서드를 사용하면 된다고 했다.
하지만 이 메서드가 지원되지 않은 경우도 감안해서 아래와 같은 코드를 쓰면 언제든지 bind()를 활용할 수 있게 된다. </p><pre><code class="javascript"><span class="title">if</span> (<span class="typedef">typeof <span class="type">Function</span>.prototype.bind === "undefined") <span class="container">{
    <span class="type">Function</span>.<span class="title">prototype</span>.<span class="title">bind</span> = <span class="title">function</span> (<span class="title">thisArg</span>) {
        <span class="title">var</span> <span class="title">fn</span> = <span class="title">this</span>,
        <span class="title">slice</span> = <span class="type">Array</span>.<span class="title">prototype</span>.<span class="title">slice</span>,
        <span class="title">args</span> = <span class="title">slice</span>.<span class="title">call</span>(<span class="title">argments</span>, ;

        <span class="title">return</span> <span class="title">function</span> () {
            <span class="title">return</span> <span class="title">fn</span>.<span class="title">apply</span>(<span class="title">thisArg</span>, <span class="title">args</span>.<span class="title">concat</span>(<span class="title">slice</span>.<span class="title">call</span>(<span class="title">arguments</span>)));
        }</span>;</span>
    }
}
</code></pre><p>메서드 빌려쓰기 패턴은 잘쓰면 꽤 유용할 듯 싶다.
아무튼 이 책의 이번 장을 보면서 느낀 것은 클래스 상속이 재사용의 유일한 방책은 아니며 오히려 상속보다 더 우아한 방법으로 재사용을 할 수 있고 그것을 잘 활용해야한다는 점이다. </p>
                        </div>
                        <hr />
                                            
                        <div class="row-fluid">
                            
                            <div class="pull-right">
                                <a href="/post/Amazon-Web-Service" class="btn btn-info">Amazon Web Service <i class="icon-white icon-chevron-right"></i></a>
                            </div>
                            

                            
                        </div>
                    

                        <div class="row-fluid">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = ''; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

                    </div>
                </div>
            </div>
            <div class="row">
            </div>
        </div>
    </div>
    <!--<div class="row">-->
        <!--<div class="offset3 span9">-->
            <!--<strong>tags</strong> :-->
            <!---->
            <!--<a href="/tag/Javscript">Javscript</a>&nbsp;-->
            <!---->
            <!--<a href="/tag/patterns">patterns</a>&nbsp;-->
            <!---->
        <!--</div>-->
    <!--</div>-->
</div><!-- /container -->


        <footer class="footer">
        <div class="container">
            <div class="row">
                <div class="span12 ">
                    <div class="well">
                        <p class="pull-right"><a href="#">Back to top</a></p>
                            <strong>haroopress</strong> developed by <a href="http://twitter.com/rhiokim" target="_blank">@rhiokim</a>,<a href="http://twitter.com/haroopress" target="_blank">@haroopress</a> and source in <a href="https://github.com/rhiokim/haroopress" target="_blank">github</a><br/>
                            Designed and built with all the love in the world <a href="http://twitter.com/twitter" target="_blank">@twitter</a> by <a href="http://twitter.com/mdo" target="_blank">@mdo</a> and <a href="http://twitter.com/fat" target="_blank">@fat</a>.<br />
                            Code licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>. Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.
                    </div>
                </div>
            </div>
        </div>
    </footer>

    


</body>
</html>
